# gRPC-example driver

The grpc example driver is a fully functional implmentation of an openBOS device driver. The purpose of this example is to demonstrate the concepts needed to develop drivers for OpenBOS.

## Usage 
Applications can get and set values on the servers internal statemachine using by implementing a `GetSetRun` compliant grpc client.

You can see how clients *directly* get and set values in `client.py`. In production only the `devctrl` daemon would do this.

The `GetSetRun` service implements 2 methods: 
1. Get
2. Set

We expect that a `run` service will need to be added in the future to perform sequences of operations on the remote device.

## Overview of files
It helps to have `comms.proto` open so you can see the message types and services defined in the protocol buffer language.

- `server.py` contains the implementations of the GRPC methods of the `GetSetRun` server.
- `client.py` contains the 2 methods you can use to access the `GetSetRun` service.
- `statemachine.py` is used to store and mutate the values exposed by this driver. A typical driver would have a file with lower-level code used to access information on physical devices in a driver/protocol specific way.
- `known_points.json` maps driver specific URIs to the internal point namespace. A typical driver would parse connection/addressing paramters from the URI provided in GetRequest.Key. In this example, static mapping is used to address internal points. For protocols/networks that don't have static addresses the driver must store state used to convert between static MACs/device ids encoded in the URI and dynamic network addresses.
- `client_test.py` is used to validate that the server behaves as expected.
- `comms_pb2_grpc.py` auto-generated by grpc. Provides the super classes used to build the handlers for the servers method calls.
- `comms_pb2.py` auto-generated by grpc.
- `comms_pb2.pyi` auto-generated by grpc. Contains the Python instances of each message class defined in `comms.proto`.

## Architecture
In openBOS values are accessed on remote devices through a series of reverse proxy servers. The typical flow is:

```
               [system_model]
             rpc     │     rpc         OT_protocol
[client_app] --> [devctrl] --> [driver_1] --> [device_1]
                     │              └-------> [device_2]
                     └-------> [driver_2] --> [device_3]
```

The purpose of this relay architecture is to provide a friendly developer experience where client applications **don't** need to know:
- the internal namespace of openBOS, 
- what drivers must be used to access which points,
- how to use the myriad of OT (operational technology) and IoT protocols needed to talk to specific devices.
- the internal namespace of devices drivers.

**All** that a client app or driver programmer needs to know is the `get` and `set` commands.
